<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <!-- <title>JupyterLab Server Options</title> -->
  <style>
    label { display: block; margin-top: 1em; font-weight: bold; }
    select, input[type="text"], input[type="number"], input[type="checkbox"] {
      width: 100%; padding: 6px; border-radius: 4px; border: 1px solid #ccc;
    }
    fieldset { border: 1px solid #ccc; border-radius: 6px; padding: 10px; }
    .center-button { display: flex; justify-content: center; margin-top: 20px; }
    .start-button {
      background-color: #f97316;
      color: white;
      padding: 12px 36px;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
      font-size: 16px;
      border: none;
    }
    .start-button:hover { background-color: #ea580c; }
    button[type="submit"]:not(.start-button) {
      display: none;
    }
    .info-message, .success-message, .warning-message, .error-message {
      border-radius: 4px;
      padding: 10px;
      margin: 10px 0;
      font-size: 14px;
    }
    .info-message { background-color: #e4f2ff; border: 1px solid #b3d7ff; }
    .success-message { background-color: #d1fae5; border: 1px solid #86efac; color: #065f46; }
    .warning-message { background-color: #fef3c7; border: 1px solid #fcd34d; color: #92400e; }
    .error-message { background-color: #fee2e2; border: 1px solid #fca5a5; color: #991b1b; }
    .loading { text-align: center; margin: 20px 0; font-style: italic; color: #666; }
    .node-status { margin-top: 10px; padding: 8px; font-size: 0.9em; }

    select option:disabled {
      color: #999 !important;
      background-color: #f5f5f5 !important;
      font-style: italic;
    }

    .node-unavailable {
      color: #dc2626;
      background-color: #fef2f2;
    }

    .node-warning {
      color: #d97706;
      background-color: #fffbeb;
    }

    .node-available {
      color: #059669;
      background-color: #ecfdf5;
    }
    .checkbox-container {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-top: 1em;
      padding: 12px;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      background-color: #f9fafb;
    }

    .checkbox-container input[type="checkbox"] {
      width: auto;
      margin: 0;
      transform: scale(1.2);
    }

    .checkbox-container label {
      margin: 0;
      font-weight: normal;
      color: #374151;
      cursor: pointer;
    }

    .checkbox-container:hover {
      background-color: #f3f4f6;
    }

    .load-balancer-info {
      background-color: #f0f9ff;
      border: 1px solid #0ea5e9;
      border-radius: 6px;
      padding: 10px;
      margin: 10px 0;
      font-size: 0.9em;
    }

    .score-badge {
      display: inline-block;
      padding: 2px 6px;
      border-radius: 12px;
      font-size: 0.8em;
      font-weight: bold;
      color: white;
    }

    .score-excellent { background-color: #059669; }
    .score-good { background-color: #0891b2; }
    .score-warning { background-color: #d97706; }
    .score-poor { background-color: #dc2626; }
  </style>
  <script>
    let availableNodes = [];
    let loadBalancerData = null;
    const DISCOVERY_API_URL = "http://10.21.73.116:15002/";

    window.onload = async function () {
      await checkApiStatus();
      await loadNodes();

      const imageSelect = document.getElementById("image-select");
      imageSelect.addEventListener("change", () => {
        updateImageInfo(imageSelect.value);
        updateNodeSelection(imageSelect.value);
      });

      const useRandomCheckbox = document.getElementById("use-random");
      useRandomCheckbox.addEventListener("change", () => {
        const isRandom = useRandomCheckbox.checked;
        document.getElementById("manual-node-select").style.display = isRandom ? "none" : "block";
        updateNodeSelection(imageSelect.value);
      });

      const nodeDropdown = document.getElementById("node-select");
      nodeDropdown.addEventListener("change", () => {
        const selectedValue = nodeDropdown.value;
        if (!selectedValue) {
          document.getElementById("node-status").innerHTML = `<div class='info-message'>Select a node from dropdown above. ðŸ”´ = Unavailable, ðŸŸ¡ = Warning, ðŸŸ¢ = Available</div>`;
          return;
        }

        const selected = availableNodes.find(n => n.hostname === selectedValue);
        if (selected) {
          updateNodeDetails(selected);
        } else {
          nodeDropdown.value = ""; // Reset selection
          document.getElementById("node-status").innerHTML = `<div class='error-message'>Selected node is not available. Please choose another node.</div>`;
        }
      });

      updateImageInfo(imageSelect.value);
      updateNodeSelection(imageSelect.value);
    };

    async function checkApiStatus() {
      const statusDiv = document.getElementById("api-status");
      try {
        const res = await fetch(`${DISCOVERY_API_URL}/health-check`);
        const data = await res.json();
        statusDiv.innerHTML = `<div class='success-message'>
          âœ“ Discovery API Connected<br><small>${data.message}</small></div>`;
      } catch (e) {
        statusDiv.innerHTML = `<div class='error-message'>
          âœ— Discovery API Unreachable<br><small>Error: ${e.message}</small></div>`;
      }
    }

    function updateImageInfo(imageValue) {
      const imageSelect = document.getElementById("image-select");
      const selectedOption = imageSelect.options[imageSelect.selectedIndex];
      const description = selectedOption.getAttribute("data-desc") || "No description available.";
      const isGpu = imageValue.toLowerCase().includes("gpu");

      const imageInfo = document.getElementById("image-info");
      imageInfo.innerHTML = `<strong>${isGpu ? "GPU Image" : "CPU Image"}:</strong> ${description}`;
      imageInfo.className = isGpu ? "info-message success-message" : "info-message";
    }

    function getScoreClass(score) {
      if (score <= 30) return 'score-excellent';
      if (score <= 50) return 'score-good';
      if (score <= 70) return 'score-warning';
      return 'score-poor';
    }

    function getScoreText(score) {
      if (score <= 30) return 'Excellent';
      if (score <= 50) return 'Good';
      if (score <= 70) return 'Fair';
      return 'Poor';
    }

    function updateNodeSelection(imageValue) {
      const nodeStatus = document.getElementById("node-status");
      const isRandom = document.getElementById("use-random").checked;
      const useGpu = imageValue.toLowerCase().includes("gpu");

      if (availableNodes.length === 0) {
        nodeStatus.innerHTML = `<div class='warning-message'>No nodes available.</div>`;
        return;
      }

      if (isRandom) {
        // Gunakan node yang dipilih oleh load balancer
        if (loadBalancerData && loadBalancerData.selected_node) {
          let selectedNode = loadBalancerData.selected_node;

          console.log("Load balancer data:", loadBalancerData);
          console.log("Selected node by load balancer:", selectedNode);
          console.log("Available nodes sorted by score:", loadBalancerData.all_available_nodes);

          // TEMPORARY FIX: Override dengan node score terbaik jika load balancer salah pilih
          if (loadBalancerData.all_available_nodes && loadBalancerData.all_available_nodes.length > 0) {
            const sortedNodes = loadBalancerData.all_available_nodes.sort((a, b) =>
              (a.load_score || 100) - (b.load_score || 100)
            );

            // Jika selected_node bukan yang score terbaik, override
            if (selectedNode.load_score !== sortedNodes[0].load_score) {
              console.warn("Load balancer selected wrong node, overriding with best score node");
              selectedNode = sortedNodes[0];
            }
          }

          // Validasi apakah node cocok dengan requirement
          if (useGpu && !selectedNode.has_gpu) {
            // Jika butuh GPU tapi selected node tidak punya, cari alternatif
            const gpuNodes = availableNodes.filter(n => n.has_gpu && isNodeHealthy(n));
            if (gpuNodes.length === 0) {
              nodeStatus.innerHTML = `<div class='error-message'>No GPU nodes available that meet criteria (CPU &lt; 60%, Memory &lt; 60%, Containers &lt; 5). Load balancer selected CPU-only node.</div>`;
              return;
            }
            // Pilih GPU node dengan score terbaik
            const bestGpuNode = gpuNodes.reduce((best, current) =>
              (current.load_score || 100) < (best.load_score || 100) ? current : best
            );
            updateNodeDetails(bestGpuNode, true);
          } else {
            updateNodeDetails(selectedNode, true);
          }
        } else {
          // Fallback ke metode lama jika load balancer data tidak tersedia
          const suitableNodes = availableNodes.filter(n => {
            if (useGpu && !n.has_gpu) return false;
            return isNodeHealthy(n);
          });

          if (suitableNodes.length === 0) {
            const reason = useGpu ? "Node tidak support penggunaan GPU atau" : "Semua node";
            nodeStatus.innerHTML = `<div class='error-message'>${reason} sedang overload (>60% CPU/Memory atau â‰¥5 containers). Coba refresh untuk update data terbaru.</div>`;
            return;
          }

          const selectedNode = suitableNodes.reduce((best, current) =>
            (current.load_score || current.memory_usage_percent || 100) < (best.load_score || best.memory_usage_percent || 100) ? current : best
          );
          updateNodeDetails(selectedNode);
        }
      } else {
        // Manual selection - populate dropdown
        populateNodeDropdown(useGpu);
        nodeStatus.innerHTML = `<div class='info-message'>Select a node from dropdown above. ðŸ”´ = Unavailable, ðŸŸ¡ = Medium Load, ðŸŸ¢ = Available</div>`;
      }
    }

    function isNodeHealthy(node) {
      const totalActiveContainers = (node.active_jupyterlab || 0) + (node.active_ray || 0);
      const cpuUsage = node.cpu_usage_percent || 0;
      const memUsage = node.memory_usage_percent || 0;
      return totalActiveContainers < 5 && cpuUsage <= 60 && memUsage <= 60;
    }

    function populateNodeDropdown(useGpu) {
      const nodeSelect = document.getElementById("node-select");
      nodeSelect.innerHTML = `<option value="">-- Select Node --</option>`;

      // Sort nodes by load_score if available
      const sortedNodes = [...availableNodes].sort((a, b) =>
        (a.load_score || 100) - (b.load_score || 100)
      );

      sortedNodes.forEach(n => {
        const gpuSuitable = useGpu ? n.has_gpu : true;
        const isHealthy = isNodeHealthy(n);
        const isAvailable = gpuSuitable && isHealthy;

        const cpuUsage = n.cpu_usage_percent || 0;
        const memUsage = n.memory_usage_percent || 0;
        const totalActiveContainers = (n.active_jupyterlab || 0) + (n.active_ray || 0);

        // Status indicators
        let statusIcon = "ðŸŸ¢";
        let statusText = "";

        if (!gpuSuitable) {
          statusIcon = "âŒ";
          statusText = " [GPU Required]";
        } else if (totalActiveContainers >= 5) {
          statusIcon = "ðŸ”´";
          statusText = " [Too Many Containers]";
        } else if (cpuUsage > 60 || memUsage > 60) {
          statusIcon = "ðŸ”´";
          statusText = " [High Usage - Filtered Out]";
        } else if (totalActiveContainers >= 3 || cpuUsage > 40 || memUsage > 40) {
          statusIcon = "ðŸŸ¡";
          statusText = " [Medium Load]";
        }

        // Add load score info if available
        const scoreInfo = n.load_score ? ` | Score: ${n.load_score}` : "";
        const label = `${statusIcon} ${n.hostname} (${n.ip}) | CPU: ${parseFloat(cpuUsage).toFixed(1)}% | RAM: ${parseFloat(memUsage).toFixed(1)}%${scoreInfo}${statusText}`;

        const option = document.createElement("option");
        option.value = isAvailable ? n.hostname : "";
        option.text = label;
        option.disabled = !isAvailable;

        if (!isAvailable) {
          option.style.color = "#999";
          option.style.backgroundColor = "#f5f5f5";
        }

        nodeSelect.appendChild(option);
      });
    }

    function updateNodeDetails(node, isLoadBalanced = false) {
      const nodeStatus = document.getElementById("node-status");
      const cpuUsage = parseFloat(node.cpu_usage_percent || 0).toFixed(1);
      const memUsage = parseFloat(node.memory_usage_percent || 0).toFixed(1);
      const ramGb = parseFloat(node.ram_gb || 0).toFixed(1);
      const gpuDetail = node.gpu?.length > 0
        ? node.gpu.map(g => `${g.name} (${g.memory_used_mb}/${g.memory_total_mb}MB)`).join(", ")
        : "None";

      const totalActiveContainers = (node.active_jupyterlab || 0) + (node.active_ray || 0);
      const containerInfo = `
        <strong>Containers:</strong>
        JupyterLab: ${node.active_jupyterlab || 0} |
        Ray: ${node.active_ray || 0} |
        Total: ${node.total_containers || 0}
      `;

      // Status indicators
      const cpuStatus = parseFloat(cpuUsage) > 60 ? "ðŸ”´" : parseFloat(cpuUsage) > 40 ? "ðŸŸ¡" : "ðŸŸ¢";
      const memStatus = parseFloat(memUsage) > 60 ? "ðŸ”´" : parseFloat(memUsage) > 40 ? "ðŸŸ¡" : "ðŸŸ¢";
      const containerStatus = totalActiveContainers >= 5 ? "ðŸ”´" : totalActiveContainers >= 3 ? "ðŸŸ¡" : "ðŸŸ¢";

      // Load balancer info
      let loadBalancerInfo = "";
      if (isLoadBalanced && loadBalancerData) {
        const algorithm = loadBalancerData.load_balancing?.algorithm || "unknown";
        const counter = loadBalancerData.load_balancing?.round_robin_counter || 0;
        const scoreClass = node.load_score ? getScoreClass(node.load_score) : 'score-good';
        const scoreText = node.load_score ? getScoreText(node.load_score) : 'N/A';

        loadBalancerInfo = `
          <div class='load-balancer-info'>
            ${loadBalancerData.all_available_nodes && loadBalancerData.all_available_nodes.length > 1 ?
              `<br><small>Node dengan score rendah (terbaik): ${Math.min(...loadBalancerData.all_available_nodes.map(n => n.load_score || 100))}</small>` : ''}
          </div>
        `;
      }

      nodeStatus.innerHTML = `
        ${loadBalancerInfo}
        <div class='success-message node-status'>
          <strong>Selected Node: ${node.hostname}</strong><br>
          ${cpuStatus} CPU usage: ${cpuUsage}% of ${node.cpu} cores | ${memStatus} RAM usage: ${memUsage}% of ${ramGb}GB<br>
          ${containerStatus} ${containerInfo}<br>
          <strong>GPU:</strong> ${gpuDetail}<br>
          <small>IP: ${node.ip}</small>
        </div>
      `;

      document.getElementById("input-node").value = node.hostname;
      document.getElementById("input-node-ip").value = node.ip;
    }

    async function loadNodes() {
      const summaryDiv = document.getElementById("nodes-summary");
      const debugDiv = document.getElementById("debug-info");

      try {
        // Call the load balancer endpoint
        const res = await fetch(`${DISCOVERY_API_URL}/available-nodes`);
        if (!res.ok) throw new Error(`HTTP ${res.status}: ${res.statusText}`);

        const data = await res.json();
        loadBalancerData = data; // Store load balancer response

        // Extract nodes from load balancer response
        let nodes = data.all_available_nodes || data.data || data;
        if (!Array.isArray(nodes)) {
          // Fallback: get nodes from separate endpoint
          const fallbackRes = await fetch(`${DISCOVERY_API_URL}/all-nodes`);
          nodes = await fallbackRes.json();
        }

        availableNodes = Array.isArray(nodes) ? nodes : [];

        const gpuNodes = availableNodes.filter(n => n.has_gpu).length;
        const healthyNodes = availableNodes.filter(n => isNodeHealthy(n));

        // Container stats
        const totalJupyter = availableNodes.reduce((sum, n) => sum + (n.active_jupyterlab || 0), 0);
        const totalRay = availableNodes.reduce((sum, n) => sum + (n.active_ray || 0), 0);
        const totalContainers = availableNodes.reduce((sum, n) => sum + (n.total_containers || 0), 0);

        const statusIcon = healthyNodes.length > 0 ? "ðŸŸ¢" : "ðŸ”´";
        const statusText = healthyNodes.length === availableNodes.length
          ? "All nodes healthy"
          : `${healthyNodes.length}/${availableNodes.length} nodes available`;

        // Load balancer summary
        let lbSummary = "";
        if (loadBalancerData && loadBalancerData.load_balancing) {
          const lb = loadBalancerData.load_balancing;
          // lbSummary = `<br><strong>Load Balancer:</strong> ${lb.algorithm?.replace(/_/g, ' ').toUpperCase()} (Round #${lb.round_robin_counter})`;
        }

        summaryDiv.innerHTML = `<div class='info-message'>
          <strong>Cluster Status:</strong> ${statusIcon} ${statusText}
          (${gpuNodes} GPU, ${availableNodes.length - gpuNodes} CPU-only)<br>
          <strong>Total Container yang Running:</strong>
          JupyterLab: ${totalJupyter} |
          Ray: ${totalRay} |
          Total: ${totalContainers}${lbSummary}<br>
        </div>`;

        const imageSelect = document.getElementById("image-select");
        updateNodeSelection(imageSelect.value);
      } catch (e) {
        document.getElementById("node-status").innerHTML = `<div class='error-message'>Failed to load node info<br><small>${e.message}</small></div>`;
        debugDiv.style.display = "block";
        debugDiv.innerHTML = `<div class="debug-info"><strong>Debug:</strong><br>${e.message}</div>`;
      }
    }
  </script>
</head>
<body>
  <form action="{{ url }}" method="post">
    <fieldset>
      <div id="api-status"></div>
      <div id="nodes-summary"></div>

      <label for="image">Docker Image:</label>
      <select name="image" id="image-select" required>
        <option value="danielcristh0/jupyterlab:cpu" data-desc="CPU-only JupyterLab for basic tasks (include numpy, pandas, matplotlib)">danielcristh0/jupyterlab:cpu</option>
        <option value="danielcristh0/jupyterlab:gpu" data-desc="GPU-enabled JupyterLab with CUDA 12 support (include torch)">danielcristh0/jupyterlab:gpu</option>
      </select>
      <div id="image-info" class="info-message"></div>

      <div class="checkbox-container">
        <input type="checkbox" id="use-random" checked />
        <label for="use-random">Random Select</label>
      </div>

      <div id="manual-node-select" style="display: none; margin-top: 1em;">
        <label for="node-select">Select a Node:</label>
        <select id="node-select" name="node-select">
          <option value="">-- Select Node --</option>
        </select>
      </div>

      <label>Node Selection:</label>
      <div id="node-status" class="loading">Loading node information...</div>

      <input type="hidden" name="node" id="input-node" />
      <input type="hidden" name="node_ip" id="input-node-ip" />

      <div class="center-button">
        <button type="submit" class="start-button">Start JupyterLab Server</button>
      </div>

      <div id="debug-info" style="display: none;"></div>
    </fieldset>
  </form>
  <script>
    document.querySelector("form").addEventListener("submit", function (e) {
      const nodeInput = document.getElementById("input-node");
      const nodeIpInput = document.getElementById("input-node-ip");
      const useRandom = document.getElementById("use-random").checked;
      const selectedHostname = document.getElementById("node-select").value;

      if (!nodeInput.value || !nodeIpInput.value) {
        if (!useRandom && selectedHostname) {
          const node = availableNodes.find(n => n.hostname === selectedHostname);
          if (node) {
            updateNodeDetails(node);
          } else {
            e.preventDefault();
            alert("Node tidak valid. Silakan pilih ulang.");
            return false;
          }
        } else {
          e.preventDefault();
          alert("Node belum siap atau Discovery API masih belum bisa diakses.");
          return false;
        }
      }
    });
  </script>
</body>
</html>